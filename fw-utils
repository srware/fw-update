#!/usr/bin/python

#
# Written by Scott Ware
#
# Version 0.0.1
#

import gobject
import os
import io
import sys
import time
import json
import subprocess
import urllib2
import urlparse
import tarfile
import tempfile
import shutil

MOUNT_POINT = "/update"
UPDATE_DESTINATION = "/update/recovery"
BACKUP_DESTINATION = "/update/recovery/backup"

UPDATE_FORMAT = ['image-name.txt', 'rootfs.tar.bz2', 'boot.hddimg', 'u-boot.bin', 'u-boot.env']

def is_supported_platform():
    	platform_file = open('/sys/class/dmi/id/board_name', 'r')
    	platform = platform_file.readline()
    	platform_file.close()
	
	if platform is "BODEGA BAY" or "SALT BAY":
    		return True

    	return False

def download_file(url):
	try:
		u = urllib2.urlopen(url)
	except (IOError, ValueError) as error:
		print "Error: Unable to obtain update file. Check file path or url is valid and ensure system is online."
		return None

    	scheme, netloc, path, query, fragment = urlparse.urlsplit(url)
    	f = tempfile.NamedTemporaryFile(delete=False)

        meta = u.info()
        meta_func = meta.getheaders if hasattr(meta, 'getheaders') else meta.get_all
        meta_length = meta_func("Content-Length")
        file_size = None

        if meta_length:
            	file_size = int(meta_length[0])

        file_size_dl = 0
        block_sz = 8192

	try:
        	while True:
            		buffer = u.read(block_sz)
            		if not buffer:
                		break

            		file_size_dl += len(buffer)
            		f.write(buffer)

            		status = "{0:16}".format(file_size_dl)

            		if file_size:
				status += "/{}".format(file_size)
                		status += "   [{0:6.2f}%]".format(file_size_dl * 100 / file_size)

            		sys.stdout.write("\rDownloading Update File: " + status)
			sys.stdout.flush()

	except IOError as error:
		print error.message

	return f.name

def unmount_update_filesystem():
	if os.path.ismount(MOUNT_POINT):
		subprocess.call("umount " + MOUNT_POINT, shell=True)

def print_usage():
	print "\nUsage:\n"
	print "fw-utils update [URL\FILEPATH]: Flash an update image to the device."
	print "fw-utils restore: Restore the device to factory defaults."
	print "fw-utils help: Prints this usage guide."
	sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) == 2 and sys.argv[1] == "help":
		print_usage()

	if (len(sys.argv) < 2):
		print "Please specify a command!"
		print_usage()
		
	# Check Platform
	if not is_supported_platform():
		print "Error: This is not a supported platform!"
		sys.exit(1)

	os.system('clear')

	#
	# Update
	#

	if sys.argv[1] == "update":
		
		print "\nUpdate Device Firmware\n=======================\n"

		# Check path argument
		if (len(sys.argv) < 3):
			print "Error: No URL or local file path specified!"
			print_usage()

		# Check URL/File
		if os.path.isfile(sys.argv[2]):
			update_path = os.path.abspath(sys.argv[2])
		else:
			update_path = download_file(sys.argv[2])
			
			if update_path is None:
				sys.exit(1)

		print "Checking update file..."
			
		# Check we are working with a valid update file
		if not tarfile.is_tarfile(update_path):
			print "Error: This is not a valid update file!"
			sys.exit(1)

		# Load our update file		
		update_file = tarfile.open(name=update_path)

		# Check contents of update file are valid
		if cmp(update_file.getnames(), UPDATE_FORMAT) != 0:
			print "Error: This is not a valid update file!"
			update_file.close()
			sys.exit(1)

		# Make sure update partition is not in use
		subprocess.call("modprobe -r g_multi", shell=True)

		# Create mount point if it doesn't exist
		if not os.path.exists(MOUNT_POINT):
    			os.makedirs(MOUNT_POINT)
		# Make sure the update partition is not mounted
		else:
			unmount_update_filesystem()

		# Mount update partition
		result = subprocess.call("mount -o loop,offset=1048576 /dev/disk/by-partlabel/update " + MOUNT_POINT, shell=True)
		if(result != 0):
			print "Error: Unable to mount update partition."
			update_file.close()
			sys.exit(1)

		# Create update directory if it doesn't exist
		if not os.path.exists(UPDATE_DESTINATION):
    			os.makedirs(UPDATE_DESTINATION)

		# Create backup if necessary
		if len(os.listdir(UPDATE_DESTINATION)) > 0:

			print "Backing up current image files..."
			
			# Create backup directory
			if not os.path.exists(BACKUP_DESTINATION):
    				os.makedirs(BACKUP_DESTINATION)

			backup_files = os.listdir(UPDATE_DESTINATION)
			for file_name in backup_files:
    				full_file_name = os.path.join(UPDATE_DESTINATION, file_name)
    				if (os.path.isfile(full_file_name)):
        				shutil.copy(full_file_name, BACKUP_DESTINATION)

		# Extract update file
		print "Extracting update files..."
		update_file.extractall(path=UPDATE_DESTINATION)
		
		# Set system to flash image on reboot
		result = subprocess.call("fw_setenv bootargs_mode recovery", shell=True)
		if(result != 0):
			print "Error: Unable to configure device to flash new image."
			update_file.close()
			unmount_update_filesystem()
			sys.exit(1)
			
		update_file.close()
		unmount_update_filesystem()

		# Reboot device
		print "\nThe device will now reboot and begin flashing the new image."
		print "** DO NOT unplug or disturb the device until flashing is complete **"
		time.sleep(5)
		os.system("reboot")
		

	#
	# Recovery
	#

	#elif sys.argv[1] == "restore":

